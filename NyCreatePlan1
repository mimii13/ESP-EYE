/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package autonavigate;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.io.*;
import java.util.logging.Level;
import java.util.logging.Logger;


    

       


/**
 *
 * @author christianchamaly
 */
public class Discoverpath {
    private List<Vertex> nodes;
    private List<Edge> edges;
    private DataStore ds;
   private BluetoothClient bt;
   private ControlUIny gui;
   private List<String> visitedPoints = new ArrayList<>();
    double[] LocationX2;
    double[] LocationY2; 
    
        
   
    
    public Discoverpath(DataStore ds, BluetoothClient bt) {
        this.ds = ds;
        this.bt = bt;
        
    
 
    }

    // Funktion som √∂vers√§tter v√§derstreck till vinkel
private double getRotationFromDirection(char riktning) {
    switch (riktning) {
        case 'N': return 90.0;
        case 'E': return 0.0;
        case 'S': return 270.0;
        case 'W': return 180.0;
        default: 
            System.out.println("‚ö†Ô∏è Ok√§nd riktning: " + riktning);
            return 0.0; // Standardv√§rde om inget matchar
    }
}


    private boolean isVisited(int x, int y) {
    for (int i = 0; i < ds.locations; i++) {
        if ((int)(ds.LocationX[i] / ds.gridsize) == x && (int)(ds.LocationY[i] / ds.gridsize) == y) {
            return true;
        }
    }
    return false;
}
  private double calculateRotation(double currentDirection, double directionV) {
    double rotation = directionV - currentDirection;
    // Justera rotation till intervallet [-180, 180]
    if (rotation >= 180) rotation -= 360;
    if (rotation <= -180) rotation += 360;
    return rotation;
}
  private void updateDirection(double newDirection) {
    ds.agvDirection = newDirection % 360;
    if (ds.agvDirection < 0) ds.agvDirection += 360;
    System.out.println("üîÑ Uppdaterad riktning: " + ds.agvDirection);
}




    
    public void createPlan2(){
       
    


 int k = 0;
         nodes = new ArrayList<Vertex>();
         edges = new ArrayList<Edge>();
         
         
// Set up grid network for path finding
for (int i = 0; i < ds.columns; i++) { 
   for (int j = 0; j < ds.rows; j++) {
     
        Vertex location = new Vertex("" + (i*ds.rows + j), "Nod #" + (i*ds.rows + j)); ;
        nodes.add(location);
    }
}
System.out.println("columns: "+ds.columns);
System.out.println("rows: "+ds.rows);

double cost = 1;


for (int i = 0; i < ds.rows; i++) {
  for (int j = 0; j < ds.columns - 1 ; j++) { // Add horizontal links in both directions
      cost = 1;
        if (ds.ObstacleMatrix[i][j] != 0 || ds.ObstacleMatrix[i][j + 1] != 0) {
            continue;
        }    

      Edge dirA = new Edge("r" + nodes.get(i*ds.columns + j), nodes.get(i*ds.columns + j ), nodes.get(i*ds.columns + j + 1), cost);
      edges.add(dirA);
      Edge dirB = new Edge("l" + nodes.get(i*ds.columns + j), nodes.get(i*ds.columns + j + 1), nodes.get(i*ds.columns + j), cost);
      edges.add(dirB);
      // Om du √•teraktiverar diagonal logik, se till att den ocks√• kontrollerar mellanliggande celler korrekt.
      // F√∂r nu antar vi att den √§r korrekt bortkommenterad eller inte anv√§nds aktivt baserat p√• tidigare diskussion.
      /*
      if(i < ds.rows - 1 ){
          cost = 500;
          if(ds.ObstacleMatrix[i + 1][j + 1] != 0 || ds.ObstacleMatrix[i][j+1] != 0 || ds.ObstacleMatrix[i+1][j] != 0){ // Exempel p√• korrekt kontroll f√∂r diagonal
              continue;
          }
          Edge dirC = new Edge("1d" + nodes.get(i*ds.columns + j), nodes.get(i*ds.columns + j ), nodes.get((i+1)*ds.columns + j + 1), cost);
          edges.add(dirC);
          Edge dirD = new Edge("2d" + nodes.get(i*ds.columns + j), nodes.get((i+1)*ds.columns + j + 1), nodes.get(i*ds.columns + j), cost);
          edges.add(dirD); 
      }
      if(i > 0){ 
          cost = 500;
          if(ds.ObstacleMatrix[i - 1][j + 1] != 0 || ds.ObstacleMatrix[i][j+1] != 0 || ds.ObstacleMatrix[i-1][j] != 0){ // Exempel p√• korrekt kontroll f√∂r diagonal
              continue;
          }
          Edge dirE = new Edge("3d" + nodes.get(i*ds.columns + j), nodes.get(i*ds.columns + j ), nodes.get((i-1)*ds.columns + j + 1), cost);
          edges.add(dirE);
          Edge dirF = new Edge("4d" + nodes.get(i*ds.columns + j), nodes.get((i-1)*ds.columns + j + 1), nodes.get(i*ds.columns + j), cost);
          edges.add(dirF); 
      }
      */
  } 
}

// =======================================================================
// START P√Ö KODBLOCK ATT UPPDATERA/ERS√ÑTTA
// =======================================================================
for (int i = 0; i < ds.rows - 1; i++) {
  for (int j = 0; j < ds.columns; j++) { // Add vertical links in both directions 
    cost = 2;
    
    // KORRIGERAD KOD: Kontrollera om N√ÖGON av de tv√• cellerna (aktuell eller den under) √§r ett hinder
    if (ds.ObstacleMatrix[i][j] != 0 || ds.ObstacleMatrix[i + 1][j] != 0) {
       continue; // Hoppa √∂ver om n√•gon cell √§r ett hinder
    }
    // Om b√•da √§r fria, l√§gg till kanterna
    Edge dirC = new Edge("d" + nodes.get(i*ds.columns + j), nodes.get(i*ds.columns + j ), nodes.get((i+1)*ds.columns + j ), cost);
    edges.add(dirC);
    Edge dirD = new Edge("u" + nodes.get(i*ds.columns + j), nodes.get((i+1)*ds.columns + j), nodes.get(i*ds.columns + j ), cost);
    edges.add(dirD);
  } 
}
// =======================================================================
// SLUT P√Ö KODBLOCK ATT UPPDATERA/ERS√ÑTTA
// =======================================================================

Graph graph = new Graph(nodes, edges);
DijkstrasAlgorithm dijkstra = new DijkstrasAlgorithm(graph);
int startnode = 0;      
int endnode = 0;
// ‚ùå Rensa tidigare ritad v√§g fr√•n ObstacleMatrix



// Convert from Location coordinates to node id
for (int j_loop = 0; j_loop < ds.locations-1; j_loop++) { // Bytte namn p√• loopvariabeln j till j_loop f√∂r tydlighet
    
    
              switch (ds.Direction[j_loop+1]) { // Anv√§nd j_loop h√§r
                
                 case 'N':
                     {
                         if(j_loop == 0){ // Anv√§nd j_loop h√§r
                         int x = (int)(ds.robotX/ds.gridsize);
                         int y = (int)(ds.robotY/ds.gridsize);
                
                         startnode = (int)((y)* ds.columns) + (x);
                         x = (int)(ds.LocationX[j_loop+1]/ds.gridsize); // Anv√§nd j_loop h√§r
                         y = (int)(ds.LocationY[j_loop+1]/ds.gridsize); // Anv√§nd j_loop h√§r
                         endnode = (int)((y+3) * ds.columns) + x;   
                         break;
                         }
                         else{
                         int x = 0;
                         int y = 0;
                         startnode = endnode;
                         x = (int)(ds.LocationX[j_loop+1]/ds.gridsize); // Anv√§nd j_loop h√§r
                         y = (int)(ds.LocationY[j_loop+1]/ds.gridsize); // Anv√§nd j_loop h√§r
                         endnode = (int)((y+3)* ds.columns) + (x);
                         break;
                         }
                         
                         
                         
                     }
                 case 'E':
                     {
                         if(j_loop == 0){ // Anv√§nd j_loop h√§r
                         int x = (int)(ds.robotX/ds.gridsize);
                         int y = (int)(ds.robotY/ds.gridsize);
                
                         startnode = (int)((y)* ds.columns) + x;
                         x = (int)(ds.LocationX[j_loop+1]/ds.gridsize); // Anv√§nd j_loop h√§r
                         y = (int)(ds.LocationY[j_loop+1]/ds.gridsize); // Anv√§nd j_loop h√§r
                         endnode = (int)((y) * ds.columns) + x+3; 
                         break;
                         }
                         else{
                         int x = 0;
                         int y = 0;
                         startnode = endnode;
                         x = (int)(ds.LocationX[j_loop+1]/ds.gridsize); // Anv√§nd j_loop h√§r
                         y = (int)(ds.LocationY[j_loop+1]/ds.gridsize); // Anv√§nd j_loop h√§r
                         endnode = (int)(y * ds.columns) + x+3;
                         break;
                         }           
                     }
                 case 'W':
                    {
                         if(j_loop == 0){ // Anv√§nd j_loop h√§r
                         int x = (int)(ds.robotX/ds.gridsize);
                         int y = (int)(ds.robotY/ds.gridsize);
                
                         startnode = (int)((y)* ds.columns) + x;
                         x = (int)(ds.LocationX[j_loop+1]/ds.gridsize); // Anv√§nd j_loop h√§r
                         y = (int)(ds.LocationY[j_loop+1]/ds.gridsize); // Anv√§nd j_loop h√§r
                         endnode = (int)((y) * ds.columns) + x-3;     
                         break;
                         }
                         else{
                         int x = 0;
                         int y = 0;
                         startnode = endnode;
                         x = (int)(ds.LocationX[j_loop+1]/ds.gridsize); // Anv√§nd j_loop h√§r
                         y = (int)(ds.LocationY[j_loop+1]/ds.gridsize); // Anv√§nd j_loop h√§r
                         endnode = (int)(y * ds.columns) + x-3;
                         break;
                         }                                                
                     }
                 case 'S':
                     {
                         if(j_loop == 0){ // Anv√§nd j_loop h√§r
                         int x = (int)(ds.robotX/ds.gridsize);
                         int y = (int)(ds.robotY/ds.gridsize);
                
                         startnode = (int)((y)* ds.columns) + x;
                         x = (int)(ds.LocationX[j_loop+1]/ds.gridsize); // Anv√§nd j_loop h√§r
                         y = (int)(ds.LocationY[j_loop+1]/ds.gridsize); // Anv√§nd j_loop h√§r
                         endnode = (int)((y-3) * ds.columns) + x;    
                         break;
                         }
                         else{
                         int x = 0;
                         int y = 0;
                         startnode = endnode;
                         x = (int)(ds.LocationX[j_loop+1]/ds.gridsize); // Anv√§nd j_loop h√§r
                         y = (int)(ds.LocationY[j_loop+1]/ds.gridsize); // Anv√§nd j_loop h√§r
                         endnode = (int)((y-3) * ds.columns) + (x);
                         break;
                         }
                         
                         
                         
                     }
                 default:
                         
                         break;
                         
             }
 System.out.println(ds.Direction);


//ds.antalrut = path.size();
//ds.xrobpos = new double[path.size()];
//ds.yrobpos = new double[path.size()];
// Kontrollera om m√•lpunkten redan √§r bes√∂kt
//if (isVisited((int)(ds.LocationX[j_loop+1] / ds.gridsize), (int)(ds.LocationY[j_loop+1] / ds.gridsize))) {
  //  System.out.println("‚ö†Ô∏è Hoppar √∂ver redan bes√∂kt punkt: (" + ds.LocationX[j_loop+1] + ", " + ds.LocationY[j_loop+1] + ")");
    //continue; // Hoppa √∂ver om redan bes√∂kt
//}

    dijkstra.execute(nodes.get(startnode));
ds.path = dijkstra.getPath(nodes.get(endnode));
//ds.cumulativePath.addAll(ds.path);
//ds.copypath = new LinkedList<> (path);

if (ds.path == null || ds.path.isEmpty()) {
    System.out.println("‚ùå Ingen v√§g hittades fr√•n " + startnode + " till " + endnode);
    // Om du √§r i en loop som f√∂rs√∂ker hitta v√§gar till flera punkter (vilket for-loopen med j_loop antyder),
    // b√∂r du anv√§nda 'continue' h√§r f√∂r att g√• till n√§sta m√•lpunkt ist√§llet f√∂r 'return'.
    // Om detta √§r den enda v√§gs√∂kningen, √§r 'return' ok.
    continue; // Forts√§tt till n√§sta j_loop iteration
}

//try (PrintWriter cmdWriter = new PrintWriter(new FileWriter("command.txt"))) {
// H√§mta kortaste v√§gen
for (int i = 0; i < ds.path.size()-1; i++) {
    int ipos = (int)(Integer.parseInt(ds.path.get(i).getId()) / ds.columns);
    int jpos = Integer.parseInt(ds.path.get(i).getId()) - ipos * ds.columns;
    

    // Markera rutten (kan vara kvar)
    // VARNING: Om denna kod k√∂rs samtidigt som LIDAR-tr√•den uppdaterar ds.ObstacleMatrix
    // utan synkronisering, kan det leda till problem.
    ds.ObstacleMatrix[ipos][jpos] = 3; 
    //gui.repaint();
    
}
for (int i = 0; i < ds.path.size() - 1;) {

    int ipos1 = (int) (Integer.parseInt(ds.path.get(i).getId()) / ds.columns);
    int jpos1 = Integer.parseInt(ds.path.get(i).getId()) - ipos1 * ds.columns;

    int ipos2 = (int) (Integer.parseInt(ds.path.get(i + 1).getId()) / ds.columns);
    int jpos2 = Integer.parseInt(ds.path.get(i + 1).getId()) - ipos2 * ds.columns;

    double directionV = 0.0;
    String direction = "";

    // Best√§m riktning
    if (ipos2 == ipos1 && jpos2 == jpos1 + 1) {
        direction = "0"; directionV = 0.0;
    } else if (ipos2 == ipos1 && jpos2 == jpos1 - 1) {
        direction = "180"; directionV = 180.0;
    } else if (jpos2 == jpos1 && ipos2 == ipos1 + 1) {
        direction = "90"; directionV = 90.0;
    } else if (jpos2 == jpos1 && ipos2 == ipos1 - 1) {
        direction = "270"; directionV = 270.0;
    } else if (ipos2 == ipos1 + 1 && jpos2 == jpos1 + 1) {
        direction = "45"; directionV = 45.0; // Diagonal
    } else if (ipos2 == ipos1 + 1 && jpos2 == jpos1 - 1) {
        direction = "135"; directionV = 135.0; // Diagonal
    } else if (ipos2 == ipos1 - 1 && jpos2 == jpos1 - 1) {
        direction = "225"; directionV = 225.0; // Diagonal
    } else if (ipos2 == ipos1 - 1 && jpos2 == jpos1 + 1) {
        direction = "315"; directionV = 315.0; // Diagonal
    }

    double rotation = calculateRotation(ds.agvDirection, directionV);
                  
    updateDirection(directionV);

    int finalRow = ipos2;
    int finalCol = jpos2;

    // Sammanh√§ngande r√∂relse
    int length = 1;
    int nextIpos, nextJpos;
    while (i + length < ds.path.size()) {
        nextIpos = (int) (Integer.parseInt(ds.path.get(i + length).getId()) / ds.columns);
        nextJpos = Integer.parseInt(ds.path.get(i + length).getId()) - nextIpos * ds.columns;

        // Kontrollera om riktningen √§ndras (inklusive diagonaler)
        if ((direction.equals("0") && nextJpos == jpos1 + length && nextIpos == ipos1) || // Korrigerat f√∂r att s√§kerst√§lla rak linje
            (direction.equals("180") && nextJpos == jpos1 - length && nextIpos == ipos1) || // Korrigerat
            (direction.equals("90") && nextIpos == ipos1 + length && nextJpos == jpos1) || // Korrigerat
            (direction.equals("270") && nextIpos == ipos1 - length && nextJpos == jpos1) || // Korrigerat
            (direction.equals("45") && nextIpos == ipos1 + length && nextJpos == jpos1 + length) ||
            (direction.equals("135") && nextIpos == ipos1 + length && nextJpos == jpos1 - length) ||
            (direction.equals("225") && nextIpos == ipos1 - length && nextJpos == jpos1 - length) ||
            (direction.equals("315") && nextIpos == ipos1 - length && nextJpos == jpos1 + length)) {
            finalRow = nextIpos;
            finalCol = nextJpos;
            length++;
        } else {
            break;
        }
    }

    // Skicka kommandot till AGV:n med den sista noden i str√§ckan
    String command = "GT," + finalCol * ds.gridsize + "," + finalRow * ds.gridsize +"," + rotation;
    System.out.println("‚û°Ô∏è Skickar riktning: " + command);
    bt.sendDirection(command);

    // V√§nta tills AGV:n n√•r m√•lnoden (inom ¬±5 cm)
    boolean nodeReached = false;
    while (!nodeReached) {
        double currentX = ds.robotX;
        double currentY = ds.robotY;

        double distanceX = Math.abs((finalCol * ds.gridsize) - currentX);
        double distanceY = Math.abs((finalRow * ds.gridsize) - currentY);
//        System.out.println(sistaNodenX+ ","+ sistaNodenY);
        if (distanceX <= 22 && distanceY <=13) {//√ÑNDRA OM NI VILL
            nodeReached = true;
            System.out.println("‚úÖ N√•tt nod: (" + currentX + ", " + currentY + ")");
      
            // Du anv√§nder 'k' h√§r, men 'k' inkrementeras l√§ngre ner.
            // Det kan vara s√• att du vill anv√§nda 'j_loop' om det √§r kopplat till den yttre loopen f√∂r m√•lpunkter.
            // ds.LocationX[k] = -1; 
            // ds.LocationY[k] = -1;
            break;
        }
        
       
    }
        try {
            Thread.sleep(50);
        } catch (InterruptedException e) {
            System.out.println("‚ö†Ô∏è V√§ntan avbruten: " + e.getMessage());
        }
    

    // Markera noden som bes√∂kt
    int x_coord = finalCol * ds.gridsize; // Bytte namn p√• variabeln x till x_coord
    int y_coord = finalRow * ds.gridsize; // Bytte namn p√• variabeln y till y_coord
    // Loopvariabeln 'k' h√§r nere verkar vara den som ska anv√§ndas f√∂r att markera ds.LocationX/Y.
    // Se till att 'k' har r√§tt v√§rde som motsvarar den aktuella m√•lpunkten fr√•n den yttre loopen (j_loop).
    // Det verkar som att 'k' ska vara 'j_loop' om du vill markera den aktuella m√•lpunkten som bes√∂kt.
    // Om 'k' √§r en separat r√§knare, se till att den hanteras korrekt.
    // Just nu inkrementeras 'k' i slutet av for-loopen f√∂r 'i', vilket kan vara fel.
    // Jag antar att 'k' ska relatera till 'j_loop' f√∂r att markera r√§tt LocationX/Y.
    // Om du vill markera den *aktuella* m√•lpunkten (fr√•n yttre loopen j_loop) som n√•dd:
    if (ds.LocationX.length > j_loop && ds.LocationY.length > j_loop) { // S√§kerhetskoll
        // Denna logik verkar f√∂rs√∂ka matcha den n√•dda noden med en i listan.
        // Det √§r dock oklart om 'k' √§r r√§tt index h√§r.
        // Om m√•let var att markera ds.LocationX[j_loop] som n√•dd, borde det ske mer direkt.
        // ds.LocationX[j_loop] = -1; 
        // ds.LocationY[j_loop] = -1;
    }
     
    // G√• vidare till n√§sta nod
    i += length;
    // 'k' inkrementeras h√§r, men dess anv√§ndning ovan √§r oklar i relation till 'j_loop'
    // Om 'k' √§r t√§nkt att sp√•ra segment inom en enskild v√§g (ds.path), d√• √§r det ok.
    // Men om det √§r f√∂r att markera m√•lpunkter fr√•n ds.locations, b√∂r det kopplas till j_loop.
    // k = k +1; // Denna 'k' √§r deklarerad i b√∂rjan av createPlan2. 
                // Dess anv√§ndning i slutet av inre loopen och relation till yttre loopen (j_loop) beh√∂ver ses √∂ver.
                // Om 'k' ska r√§kna antalet bes√∂kta punkter fr√•n ds.locations, b√∂r den inkrementeras
                // i den yttre loopen (j_loop) n√§r en hel v√§g till en ds.LocationX[j_loop] √§r klar.
}

// Inkrementera 'k' h√§r om 'k' √§r t√§nkt att r√§kna antalet bearbetade m√•lpunkter fr√•n ds.locations
// k = k+1; // Flytta eventuellt 'k'-inkrementeringen hit, relaterat till yttre loopen 'j_loop'

} // Slut p√• yttre for-loop (j_loop)




    }
    
    

}
