# AGV Raspberry Pi-huvudkod:
# - Bluetooth-server för överordnat system (t.ex. mobil/dator)
# - Tar emot och skickar mål till ESP32
# - Tar emot och visar position samt "REACHED" från ESP32
# - Skickar "TARGET_REACHED" till Bluetooth-klient vid bekräftelse från ESP32
# - Startar Lidar-task på kommando, skickar Lidar-data till klient
# - All logik och trådning är kommenterad

import bluetooth  # För Bluetooth RFCOMM-server
import time
import serial     # För UART (ESP32)
import struct     # För tolkning av Lidar-paket
import threading  # För att lyssna på position och köra Lidar parallellt
from collections import deque # Not actively used in this version, but was in original

# -- AGV-position, mutex för trådning --
position_lock = threading.Lock()
current_agv_x, current_agv_y = 475.0, 190.0  # Startvärde, uppdateras från ESP32
lidar_active = False # Flag to control the lidar scanning loop

# -- Lidar-inställningar --
LIDAR_PORT = "/dev/ttyUSB0"     # RPLidar C1 device (eller annan Lidar)
LIDAR_BAUDRATE = 460800         # Lidar baudrate (kan variera beroende på Lidar-modell)
CMD_LIDAR_STOP = b'\xA5\x25'    # Stoppkommando för RPLidar
CMD_LIDAR_SCAN = b'\xA5\x20'    # Start scan-kommando för RPLidar
# check_angles = [i for i in range(0, 360, 1)] # 0-359 grader, 1 grad steg (används i lidar_task)

# -- Seriell anslutning till ESP32 --
# !!! VIKTIGT: Se till att denna port matchar den faktiska anslutningen till ESP32 !!!
# Om du använder USB-till-seriell adapter kan det vara /dev/ttyUSB1, /dev/ttyACM0 etc.
# Standard GPIO UART på Pi är oftast /dev/ttyS0 (Pi 3/4/Zero W) eller /dev/ttyAMA0 (äldre Pi)
# Se till att seriell konsol är avstängd på denna port i raspi-config om du använder GPIO UART.
ESP32_SERIAL_PORT = '/dev/ttyS0' # Exempel, anpassa efter din setup
ESP32_BAUDRATE = 115200
esp_serial = None # Kommer initialiseras i main

# --- Global för aktiv Bluetooth-klient socket och dess lås ---
active_client_sock_lock = threading.Lock()
active_client_sock = None

def connect_esp32():
    """Försöker ansluta till ESP32 via seriell port."""
    global esp_serial
    try:
        esp_serial = serial.Serial(ESP32_SERIAL_PORT, ESP32_BAUDRATE, timeout=1)
        print(f"[AGV] Ansluten till ESP32 på {ESP32_SERIAL_PORT}")
        return True
    except serial.SerialException as e:
        print(f"[AGV] Kunde inte ansluta till ESP32 på {ESP32_SERIAL_PORT}: {e}")
        esp_serial = None
        return False

def update_agv_position(new_x, new_y):
    """Säker trådad uppdatering av AGV-position."""
    global current_agv_x, current_agv_y
    with position_lock:
        current_agv_x, current_agv_y = new_x, new_y

def get_agv_position():
    """Hämta aktuell AGV-position, trådsäkert."""
    global current_agv_x, current_agv_y
    with position_lock:
        return current_agv_x, current_agv_y

def parse_lidar_packet(packet_data):
    """Tolka 5-byte Lidar-paket till (vinkel, avstånd, kvalitet). Anpassad för RPLidar."""
    if len(packet_data) != 5:
        return None
    # RPLidar paketstruktur (kan variera lite mellan modeller/firmware)
    # Byte 0: S (Start Bit, alltid 1), S! (Inverterad Start Bit, alltid 0), Kvalitet (6 bitar)
    # Byte 1: Vinkel LSB (7 bitar), C (Check Bit, alltid 1)
    # Byte 2: Vinkel MSB (8 bitar)
    # Byte 3: Avstånd LSB (8 bitar)
    # Byte 4: Avstånd MSB (8 bitar)
    b0, b1, b2, b3, b4 = struct.unpack('<BBBBB', packet_data)

    quality = b0 >> 2
    angle_q6 = ((b2 << 7) | (b1 >> 1)) # Kombinera vinkelbitar
    angle_degrees = angle_q6 / 64.0    # Konvertera från Q6-format till grader

    distance_q2 = (b4 << 8) | b3       # Kombinera avståndsbitar
    distance_mm = distance_q2 / 4.0    # Konvertera från Q2-format till mm (för RPLidar)
                                       # Vissa Lidars kan ge cm direkt eller behöva annan skalning

    # Start bit check (S=1, S!=0)
    start_flag = b0 & 0x01
    inverted_start_flag = (b0 >> 1) & 0x01
    if not (start_flag == 1 and inverted_start_flag == 0):
        # print(f"Lidar packet start bit error: S={start_flag}, S!={inverted_start_flag}")
        return None
    # Check bit (C=1)
    # check_bit = b1 & 0x01
    # if not (check_bit == 1):
    #     print(f"Lidar packet check bit error: C={check_bit}")
    #     return None

    return angle_degrees % 360, max(0, distance_mm), quality


def get_lidar_scan_descriptor(ser_conn):
    """Väntar på och validerar Lidar scan descriptor (7 bytes för RPLidar)."""
    descriptor = ser_conn.read(7)
    if len(descriptor) < 7 or descriptor[:2] != b'\xA5\x5A': # Startflaggor för RPLidar descriptor
        print("[AGV] Misslyckades med att ta emot Lidar scan descriptor eller felaktig descriptor.")
        raise Exception("Misslyckades med att ta emot Lidar scan descriptor")
    print("[AGV] Lidar scan descriptor mottagen.")


def lidar_task_function():
    """Lidar-task: läser ett varv (eller kontinuerligt), skickar LIDAR:... till Bluetooth-klient."""
    global lidar_active, active_client_sock
    
    if not lidar_active: # Dubbelkolla om den ska starta
        print("[AGV_LIDAR] Lidar task anropad men lidar_active är False.")
        return

    print("[AGV_LIDAR] Lidar task startar...")
    
    local_lidar_ser = None
    try:
        local_lidar_ser = serial.Serial(LIDAR_PORT, LIDAR_BAUDRATE, timeout=1)
        print(f"[AGV_LIDAR] Ansluten till Lidar på {LIDAR_PORT}.")

        local_lidar_ser.write(CMD_LIDAR_STOP) # Stoppa eventuell tidigare scan
        time.sleep(0.2) # Ge Lidar tid att reagera
        local_lidar_ser.reset_input_buffer() # Rensa buffer
        
        local_lidar_ser.write(CMD_LIDAR_SCAN) # Starta ny scan
        print("[AGV_LIDAR] Scan-kommando skickat till Lidar.")
        
        get_lidar_scan_descriptor(local_lidar_ser) # Vänta på descriptor

        # För att samla ett helt varv (360 grader)
        # Detta är en förenklad version. Robust implementering hanterar paket som kommer oordnat,
        # och kan behöva interpolera för saknade vinklar.
        scan_data = [0.0] * 360 # Array för att lagra avstånd för varje grad
        points_collected_in_scan = 0

        while lidar_active: # Loopa så länge flaggan är satt
            packet = local_lidar_ser.read(5) # Läs ett Lidar-datapaket (5 bytes)
            if not lidar_active: break # Avbryt om flaggan ändrats under läsning
            
            if len(packet) == 5:
                result = parse_lidar_packet(packet)
                if result:
                    angle, distance_mm, quality = result
                    angle_int = int(round(angle)) # Runda till närmaste heltal för indexering
                    
                    if 0 <= angle_int < 360:
                        scan_data[angle_int] = round(distance_mm / 10.0, 1) # Konvertera mm till cm, en decimal
                        points_collected_in_scan +=1

                    # Skicka data efter ett fullt varv (eller ett visst antal punkter)
                    # Här skickar vi när vi har samlat 360 unika vinkelpunkter (förenkling)
                    # En mer robust metod skulle titta på startflaggor i Lidar-datan för att detektera nytt varv.
                    if points_collected_in_scan >= 360: # Förenklad varvdetektering
                        lidar_string = "LIDAR:" + ",".join(map(str, scan_data))
                        with active_client_sock_lock:
                            if active_client_sock:
                                try:
                                    active_client_sock.send((lidar_string + "\n").encode("utf-8"))
                                    # print("[AGV_LIDAR] Skickade Lidar-scan till klient.")
                                except Exception as e:
                                    print(f"[AGV_LIDAR] Fel vid skickning av Lidar-data: {e}")
                        scan_data = [0.0] * 360 # Återställ för nästa varv
                        points_collected_in_scan = 0
            else:
                # Timeout eller ofullständigt paket
                pass
                # print("[AGV_LIDAR] Timeout vid läsning från Lidar eller ofullständigt paket.")

    except serial.SerialException as e:
        print(f"[AGV_LIDAR] Seriell fel med Lidar ({LIDAR_PORT}): {e}")
    except Exception as e:
        print(f"[AGV_LIDAR] Oväntat fel i Lidar-task: {e}")
    finally:
        if local_lidar_ser and local_lidar_ser.is_open:
            try:
                local_lidar_ser.write(CMD_LIDAR_STOP) # Försök stoppa Lidar
                time.sleep(0.1)
                local_lidar_ser.close()
                print("[AGV_LIDAR] Lidar-anslutning stängd.")
            except Exception as e:
                print(f"[AGV_LIDAR] Fel vid stängning av Lidar: {e}")
        lidar_active = False # Se till att flaggan är falsk när tasken avslutas
        print("[AGV_LIDAR] Lidar task avslutad.")


def send_target_to_esp32(x_coord, y_coord):
    """Skicka målkoordinat till ESP32 via UART."""
    global esp_serial
    if esp_serial and esp_serial.is_open:
        cmd = f"GO,{x_coord},{y_coord}\n"
        try:
            esp_serial.write(cmd.encode())
            print(f"[AGV] Skickade GO-kommando till ESP32: X={x_coord}, Y={y_coord}")
        except Exception as e:
            print(f"[AGV] Fel vid skickning av GO-kommando till ESP32: {e}")
    else:
        print("[AGV] Kan inte skicka GO-kommando, ingen anslutning till ESP32.")

def send_stop_to_esp32():
    """Skicka STOP till ESP32."""
    global esp_serial
    if esp_serial and esp_serial.is_open:
        try:
            esp_serial.write(b"STOP\n")
            print("[AGV] Skickade STOP-kommando till ESP32.")
        except Exception as e:
            print(f"[AGV] Fel vid skickning av STOP-kommando till ESP32: {e}")
    else:
        print("[AGV] Kan inte skicka STOP-kommando, ingen anslutning till ESP32.")

def listen_for_esp32_messages():
    """Tråd: lyssnar på ESP32, uppdaterar position och hanterar "REACHED"."""
    global active_client_sock, esp_serial
    
    while True:
        if not (esp_serial and esp_serial.is_open):
            print("[ESP_LISTENER] Väntar på ESP32-anslutning...")
            if not connect_esp32(): # Försök återansluta
                time.sleep(5) # Vänta innan nytt försök
                continue # Gå till början av while-loopen
        
        try:
            if esp_serial.in_waiting > 0:
                line = esp_serial.readline().decode("utf-8", errors='ignore').strip()
                if not line:
                    continue

                # print(f"[ESP32_MSG_RAW] '{line}'") # För rå-debug av ESP32-meddelanden

                if line.startswith("POS,"):
                    parts = line.split(",")
                    if len(parts) >= 3:
                        try:
                            px = float(parts[1])
                            py = float(parts[2])
                            update_agv_position(px, py)
                            # print(f"[AGV] Position från ESP32: x={px:.2f}, y={py:.2f}")
                        except ValueError:
                            print(f"[AGV] Fel vid tolkning av position från ESP32 (ValueError): '{line}'")
                elif "REACHED" in line:
                    print("[AGV] 'REACHED' meddelande mottaget från ESP32!")
                    with active_client_sock_lock:
                        if active_client_sock:
                            try:
                                active_client_sock.send("TARGET_REACHED\n".encode("utf-8"))
                                print("[AGV] Skickade 'TARGET_REACHED' till Bluetooth-klient.")
                            except Exception as e:
                                print(f"[AGV] Fel vid skickning av 'TARGET_REACHED' till klient: {e}")
                # Annat meddelande från ESP32 kan loggas här om nödvändigt
                # elif line.startswith("Yaw:"): # Om ESP32 skickar debug-utskrifter
                #    print(f"[ESP32_DEBUG] {line}")


            else: # Ingen data väntar
                time.sleep(0.02) # Kort paus för att inte överbelasta CPU

        except serial.SerialException as e:
            print(f"[ESP_LISTENER] Seriell kommunikationsfel med ESP32: {e}")
            if esp_serial and esp_serial.is_open:
                esp_serial.close()
            esp_serial = None # Markera som frånkopplad
            time.sleep(3) # Vänta lite innan återanslutningsförsök
        except Exception as e:
            print(f"[ESP_LISTENER] Oväntat fel i listen_for_esp32_messages: {e}")
            time.sleep(1) # Kort paus innan nästa försök

def main_bluetooth_server():
    """Huvudfunktion: startar Bluetooth-server, hanterar klienter och kommandon."""
    global active_client_sock, lidar_active, esp_serial

    if not connect_esp32():
        print("[AGV] Kunde inte starta ESP32-anslutning. Avslutar kanske inte, men funktionalitet begränsad.")
        # Du kan välja att avsluta här om ESP32-anslutning är kritisk från start
        # return

    # Starta tråden som lyssnar på meddelanden från ESP32
    esp_listener_thread = threading.Thread(target=listen_for_esp32_messages, daemon=True)
    esp_listener_thread.start()

    server_sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM)
    try:
        server_sock.bind(("", bluetooth.PORT_ANY)) # Bind till alla adresser, slumpmässig ledig RFCOMM-port
        server_sock.listen(1) # Tillåt en väntande anslutning
        port = server_sock.getsockname()[1]
        
        # UUID för Serial Port Profile (SPP)
        spp_uuid = "00001101-0000-1000-8000-00805F9B34FB"
        service_name = "AGVControlServer_mimii13"

        bluetooth.advertise_service(server_sock, service_name,
                                    service_id=spp_uuid,
                                    service_classes=[spp_uuid, bluetooth.SERIAL_PORT_CLASS],
                                    profiles=[bluetooth.SERIAL_PORT_PROFILE],
                                    # provider='YourCompanyName', # Valfritt
                                    # description='AGV Control Service' # Valfritt
                                    )
        print(f"[AGV] Bluetooth-server '{service_name}' startad på port {port}. Väntar på anslutning...")

        while True: # Loop för att acceptera nya klienter efter att en har kopplat från
            client_sock_temp, client_info = server_sock.accept()
            print(f"[AGV] Bluetooth-klient ansluten: {client_info}")
            
            with active_client_sock_lock:
                if active_client_sock: # Om en gammal klient fortfarande är markerad (bör inte hända ofta)
                    try: active_client_sock.close()
                    except: pass
                active_client_sock = client_sock_temp # Sätt den nya klienten som aktiv

            try:
                while True: # Loop för att hantera kommandon från den anslutna klienten
                    data = active_client_sock.recv(1024) # Ta emot data (max 1024 bytes)
                    if not data:
                        print("[AGV] Tom data mottagen från klient, antar frånkoppling.")
                        break # Avsluta kommandoloopen för denna klient
                    
                    data_str = data.decode("utf-8", errors='ignore').strip()
                    print(f"[BT_RECV_FROM_CLIENT] '{data_str}'")

                    if data_str.startswith("GT,"): # Målkommando: Go To
                        parts = data_str.replace("GT,", "").split(",")
                        if len(parts) >= 2:
                            target_x_str, target_y_str = parts[0], parts[1]
                            try:
                                x = float(target_x_str)
                                y = float(target_y_str)
                                send_target_to_esp32(x, y)
                            except ValueError:
                                print(f"[AGV] Ogiltiga koordinater från Bluetooth: X='{target_x_str}', Y='{target_y_str}'")
                                if active_client_sock:
                                     active_client_sock.send("ERROR: Invalid coordinates format. Use GT,float,float\n".encode("utf-8"))
                        else:
                            if active_client_sock:
                                active_client_sock.send("ERROR: Invalid GT command format. Use GT,x,y\n".encode("utf-8"))


                    elif data_str == "STOP":
                        send_stop_to_esp32()
                    
                    elif data_str == "GET_POS": # Kommando för att hämta aktuell position
                         current_x, current_y = get_agv_position()
                         pos_msg = f"CURRENT_POS,{current_x:.2f},{current_y:.2f}\n"
                         if active_client_sock:
                             active_client_sock.send(pos_msg.encode("utf-8"))
                             # print(f"[AGV] Skickade position till klient: {pos_msg.strip()}")
                    
                    elif data_str == "START_LIDAR":
                        if not lidar_active:
                            lidar_active = True
                            # Starta lidar-task i en tråd om den inte redan körs
                            # Se till att lidar_task_function hanterar sin egen flagga och anslutning
                            threading.Thread(target=lidar_task_function, daemon=True).start()
                            print("[AGV] Lidar start-kommando mottaget. Försöker starta Lidar-task.")
                            if active_client_sock: active_client_sock.send("LIDAR_STARTING\n".encode("utf-8"))
                        else:
                            print("[AGV] Lidar är redan aktiv.")
                            if active_client_sock: active_client_sock.send("LIDAR_ALREADY_ACTIVE\n".encode("utf-8"))
                    
                    elif data_str == "STOP_LIDAR":
                        if lidar_active:
                            lidar_active = False # Signalera till Lidar-tasken att avsluta
                            print("[AGV] Lidar stopp-kommando mottaget. Försöker stoppa Lidar-task.")
                            if active_client_sock: active_client_sock.send("LIDAR_STOPPING\n".encode("utf-8"))
                        else:
                            print("[AGV] Lidar är inte aktiv.")
                            if active_client_sock: active_client_sock.send("LIDAR_NOT_ACTIVE\n".encode("utf-8"))
                    else:
                        if active_client_sock:
                            active_client_sock.send(f"UNKNOWN_COMMAND: {data_str}\n".encode("utf-8"))


            except bluetooth.btcommon.BluetoothError as e:
                # Detta fångar ofta frånkopplingar från klientens sida
                print(f"[AGV] Bluetooth-fel med klient {client_info}: {e}")
            except Exception as e:
                print(f"[AGV] Oväntat fel med klient {client_info}: {e}")
            finally:
                print(f"[AGV] Bluetooth-klient {client_info} frånkopplad.")
                with active_client_sock_lock:
                    # Nollställ bara om den nuvarande klienten var den som var aktiv globalt
                    if active_client_sock == client_sock_temp:
                        active_client_sock = None
                try:
                    client_sock_temp.close() # Stäng alltid den temporära socketen för denna klient
                except: pass # Ignorera fel om den redan är stängd

    except KeyboardInterrupt:
        print("\n[AGV] Avslutar Bluetooth-server på grund av KeyboardInterrupt...")
    except Exception as e:
        print(f"[AGV] Ett kritiskt fel inträffade i main_bluetooth_server: {e}")
    finally:
        print("[AGV] Stänger ner resurser...")
        if lidar_active: # Se till att Lidar-tasken signaleras att stoppa
            lidar_active = False
            time.sleep(0.5) # Ge Lidar-tasken lite tid att reagera

        if active_client_sock:
            try: active_client_sock.close()
            except: pass
        if server_sock:
            try: server_sock.close()
            except: pass
        if esp_serial and esp_serial.is_open:
            try: esp_serial.close()
            except: pass
        print("[AGV] Bluetooth-server och seriell anslutning stängda. Programmet avslutas.")

if __name__ == "__main__":
    main_bluetooth_server()
